//==============================================================================
//    S E N S I R I O N   AG,  Laubisruetistr. 50, CH-8712 Staefa, Switzerland
//==============================================================================
// Project   :  SF05 Sample Code (V1.0)
// File      :  sf05.c (V1.0)
// Author    :  RFU
// Date      :  07-Nov-2012
// Controller:  STM32F100RB
// IDE       :  µVision V4.60.0.0
// Compiler  :  Armcc
// Brief     :  Sensor Layer: Implementation of functions for sensor access.
//==============================================================================

//-- Includes ------------------------------------------------------------------
#include "sf05.h"
#include <string.h>

#include "driver/gpio.h"
#include "driver/i2c.h"
#include "esp_err.h"
#include "esp_log.h"
#include "freertos/task.h"

#include "sdkconfig.h" // generated by "make menuconfig"

#include "SDP31.h"
#include "oled1306.h"
#include "ssd1366.h"
#include "PensaGpio.h"
#include "uart_echo.h"
//uint8_t readData[9]={0,0,0,0,0,0,0,0,0};
//#include "i2c_hal.h"
//-- Defines -------------------------------------------------------------------
// Offset and scale factors from datasheet (SFM3000).
#define OFFSET_FLOW 32000.0F   // offset flow
#define OFFSET_TEMP 20000.0F   // offset temperature
#define SCALE_FLOW    140.0F   // scale factor flow
#define SCALE_TEMP    100.0F   // scale factor temperature


#define WRITE_BIT                          I2C_MASTER_WRITE /*!< I2C master write */
#define READ_BIT                           I2C_MASTER_READ  /*!< I2C master read */
#define ACK_CHECK_EN                       0x1              /*!< I2C master will check ack from slave*/
#define ACK_CHECK_DIS                      0x0              /*!< I2C master will not check ack from slave */
#define ACK_VAL                            0x0              /*!< I2C ack value */
#define NACK_VAL                           0x1              /*!< I2C nack value */
//-- Global Variables ----------------------------------------------------------
u16t currentCommand = 0x0000;
#define SDA_SDP31_PIN GPIO_NUM_18
#define SCL_SDP31_PIN GPIO_NUM_5

//==============================================================================
void SF05_Init(void){
//==============================================================================
 // I2c_Init(); // init I2C
	i2c_config_t i2c_config = {
		.mode = I2C_MODE_MASTER,
		.sda_io_num = SDA_SDP31_PIN,
		.scl_io_num = SCL_SDP31_PIN,
		.sda_pullup_en = GPIO_PULLUP_ENABLE,
		.scl_pullup_en = GPIO_PULLUP_ENABLE,
		.master.clk_speed = 100000
	};
	i2c_param_config(I2C_NUM_0, &i2c_config);
	i2c_driver_install(I2C_NUM_0, I2C_MODE_MASTER, 0, 0, 0);
}
uint8_t crc8(const uint8_t data, uint8_t crc) {
  crc ^= data;

  for ( uint8_t i = 8; i; --i ) {
    crc = ( crc & 0x80 )
      ? (crc << 1) ^ 0x31
      : (crc << 1);
  }
  return crc;
}

//==============================================================================
etError SF05_CheckCrc(u8t data[], u8t nbrOfBytes, u8t checksum){
//==============================================================================
  u8t bit;     // bit mask
  u8t crc = 0; // calculated checksum
  u8t byteCtr; // byte counter
  
  // calculates 8-Bit checksum with given polynomial
  for(byteCtr = 0; byteCtr < nbrOfBytes; byteCtr++)
  {
    crc ^= (data[byteCtr]);
    for(bit = 8; bit > 0; --bit)
    {
      if(crc & 0x80) crc = (crc << 1) ^ POLYNOMIAL;
      else           crc = (crc << 1);
    }
  }
  
  // verify checksum
  if(crc != checksum) return CHECKSUM_ERROR;
  else                return NO_ERROR;
}


float SF05_GetFlow(void)
{
  uint8_t error;    // error code
  uint8_t     data[3];  // read data array
 // int offset = 32000; // Offset for the sensor
//  float scale = 140.0; // Scale factor for Air and N2 is 140.0, O2 is 142.8
  float Flow=0;
  int result=0;
  uint8_t mycrc = 0xFF; // initialize crc variable
	esp_err_t espRc;
        error =NO_ERROR;
	i2c_cmd_handle_t cmd = i2c_cmd_link_create();

	i2c_master_start(cmd);
	espRc =i2c_master_write_byte(cmd, (I2C_ADR << 1) | I2C_MASTER_WRITE, true);//–¥µÿ÷∑

	i2c_master_write_byte(cmd, (FLOW_MEASUREMENT >> 8) & 0x00FF, true);//–¥√¸¡Ó
	i2c_master_write_byte(cmd, FLOW_MEASUREMENT & 0x00FF, true);

  	i2c_master_stop(cmd);
   	espRc = i2c_master_cmd_begin(I2C_NUM_0, cmd, 10 / portTICK_RATE_MS);
   	i2c_cmd_link_delete(cmd);

    	vTaskDelay(10 / portTICK_RATE_MS);

    	cmd = i2c_cmd_link_create();
     	i2c_master_start(cmd);

     	espRc = i2c_master_write_byte(cmd, (I2C_ADR << 1) |I2C_MASTER_READ, true);//–¥µÿ÷∑

	espRc=i2c_master_read(cmd, data, (uint8_t)3, ACK_VAL);//∂¡ ˝æ›
	i2c_master_stop(cmd);
	espRc = i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
	i2c_cmd_link_delete(cmd);

        error  |= SF05_CheckCrc (data, 2, data[2]);
        
        if(error == NO_ERROR) {result =(((data[0])<<8)|data[1]); Flow = (float)(((float)(result - OFFSET_FLOW)) / SCALE_FLOW);
        
        if(result==0)Flow=0;
        }
        else Flow=0;
     
        return Flow; 
}

float SF05_GetTemperature(void)
{
  uint8_t error;    // error code
 // u8t     checksum[1]; // checksum byte
  uint8_t     data[3];  // read data array
 // int offset = 32000; // Offset for the sensor
//  float scale = 140.0; // Scale factor for Air and N2 is 140.0, O2 is 142.8
  float Temperature=0;
  int result=0;
  uint8_t mycrc = 0xFF; // initialize crc variable
	esp_err_t espRc;
        error = NO_ERROR;
	i2c_cmd_handle_t cmd = i2c_cmd_link_create();

	i2c_master_start(cmd);
	espRc =i2c_master_write_byte(cmd, (I2C_ADR << 1) | I2C_MASTER_WRITE, true);//–¥µÿ÷∑

	i2c_master_write_byte(cmd, (TEMP_MEASUREMENT >> 8) & 0x00FF, true);//–¥√¸¡Ó
	i2c_master_write_byte(cmd, TEMP_MEASUREMENT & 0x00FF, true);

  	i2c_master_stop(cmd);
   	espRc = i2c_master_cmd_begin(I2C_NUM_0, cmd, 10 / portTICK_RATE_MS);
   	i2c_cmd_link_delete(cmd);

    	vTaskDelay(10 / portTICK_RATE_MS);

    	cmd = i2c_cmd_link_create();
     	i2c_master_start(cmd);

     	espRc = i2c_master_write_byte(cmd, (I2C_ADR << 1) |I2C_MASTER_READ, true);//–¥µÿ÷∑

	espRc=i2c_master_read(cmd, data, (uint8_t)3, ACK_VAL);//∂¡ ˝æ›
	i2c_master_stop(cmd);
	espRc = i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
	i2c_cmd_link_delete(cmd);

        error  |= SF05_CheckCrc (data, 2, data[2]);
        
        if(error == NO_ERROR) {result =(((data[0])<<8)|data[1]);     Temperature = (float)(((float)(result - OFFSET_TEMP)) / SCALE_TEMP);}
        else Temperature=0;
        if(result==0)Temperature=0;
        return Temperature; 
}

